@page "/mission-metrics"
@inject ApiClient Api
@inject ToastService ToastService
@inject OrganizationContext OrgContext
@inject UiOperationService UiOps
@implements IDisposable

<MissionsMenu />

<ManagementPageHeader
    Kicker="Gestão"
    Title="Métricas"
    Subtitle="Defina métricas para suas missões."
    PrimaryActionText="Nova métrica"
    OnPrimaryAction="OpenCreateModal" />

<div class="card">
    <div class="card-filters">
        <div class="form-row">
            <label>Missão</label>
            <select class="input" @bind="filterMissionId" @bind:after="LoadMetrics">
                <option value="">Todas</option>
                @foreach (var mission in missions)
                {
                    <option value="@mission.Id">@mission.Name</option>
                }
            </select>
        </div>
        <div class="form-row">
            <label>Busca</label>
            <InputText class="input" @bind-Value="search" />
        </div>
        <div class="form-row" style="align-self: flex-end;">
            <button class="button" @onclick="LoadMetrics">Atualizar</button>
        </div>
    </div>

    <PagedTableSection
        IsLoading="@(metrics is null)"
        IsEmpty="@(metrics is not null && metrics.Items.Count == 0)"
        Total="@(metrics?.Total ?? 0)"
        EmptyText="Nenhuma métrica encontrada.">
        <table class="table">
            <thead>
                <tr>
                    <th>Nome</th>
                    <th>Tipo</th>
                    <th>Alvo</th>
                    <th>Progresso</th>
                    <th>Confiança</th>
                    <th>Missão</th>
                    <th style="width: 120px; text-align: center;">Ações</th>
                </tr>
            </thead>
            <tbody>
                @foreach (var metric in metrics!.Items)
                {
                    var isDeleting = deletingMetricId == metric.Id;
                    var progress = metricProgress.GetValueOrDefault(metric.Id);
                    <tr>
                        <td>@metric.Name</td>
                        <td>@GetMetricTypeLabel(metric.Type)</td>
                        <td>@GetTargetLabel(metric)</td>
                        <td>
                            @if (progress is null || !progress.HasCheckins)
                            {
                                <span class="muted">—</span>
                            }
                            else
                            {
                                var statusClass = GetProgressStatusClass(progress);
                                <div class="mission-progress">
                                    <div class="progress-bar">
                                        <div class="progress-fill @statusClass" style="width: @($"{progress.Progress:F0}%")"></div>
                                    </div>
                                    <span class="progress-label">@($"{progress.Progress:F0}%")</span>
                                </div>
                            }
                        </td>
                        <td>
                            @if (progress is null || !progress.HasCheckins)
                            {
                                <span class="confidence-badge no-data">Sem dados</span>
                            }
                            else
                            {
                                var (confClass, confLabel) = GetConfidenceDisplay(progress.Confidence);
                                <span class="confidence-badge @confClass">@GetConfidenceStarsText(progress.Confidence) @confLabel</span>
                            }
                        </td>
                        <td>@GetMissionName(metric.MissionId)</td>
                        <td style="text-align: center;">
                            <CrudRowActions
                                EditTitle="Editar métrica"
                                OnEdit="@(() => OpenEditMetricModal(metric))"
                                IsDeleteConfirming="@isDeleting"
                                DeleteTitle="Excluir métrica"
                                OnDelete="@(() => HandleDeleteMetricClick(metric.Id))" />
                        </td>
                    </tr>
                }
            </tbody>
        </table>
    </PagedTableSection>
</div>

@if (isModalOpen)
{
    <Modal Title="Nova métrica" OnClose="CloseModal" Size="lg">
        <EditForm Model="@newMetric" OnValidSubmit="CreateMetric">
            <DataAnnotationsValidator />
            <div class="metrics-form-container">
                <div class="metrics-form-header">
                    <div class="form-row">
                        <label>Missão</label>
                        <select class="input" @bind="createMissionId">
                            <option value="">Selecione uma missão</option>
                            @foreach (var mission in missions)
                            {
                                <option value="@mission.Id">@mission.Name</option>
                            }
                        </select>
                    </div>
                    <div class="form-row">
                        <label>Nome da métrica</label>
                        <InputText class="input" placeholder="Ex: Taxa de conversão, NPS, etc." @bind-Value="newMetric.Name" />
                    </div>
                </div>

                <div class="metrics-form-selectors">
                    <div class="metrics-selector-btn">
                        <svg class="metrics-selector-icon" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M4 6h12M4 10h12M4 14h12" stroke-linecap="round"/>
                        </svg>
                        <select value="@createMetricTypeValue" @onchange="OnMetricTypeChanged">
                            <option value="">Tipo de métrica</option>
                            @foreach (var metricType in Enum.GetValues<MetricType>())
                            {
                                <option value="@metricType">@GetMetricTypeLabel(metricType)</option>
                            }
                        </select>
                        <svg class="metrics-selector-icon" viewBox="0 0 20 20" fill="currentColor">
                            <path d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z"/>
                        </svg>
                    </div>

                    @if (createMetricTypeValue == nameof(MetricType.Quantitative))
                    {
                        <div class="metrics-selector-btn">
                            <svg class="metrics-selector-icon" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M3 10h14M10 3v14" stroke-linecap="round"/>
                            </svg>
                            <select @bind="createQuantitativeTypeValue">
                                <option value="">Modo de mensuração</option>
                                @foreach (var qType in Enum.GetValues<QuantitativeMetricType>())
                                {
                                    <option value="@qType">@GetQuantitativeTypeIcon(qType) @GetQuantitativeTypeLabel(qType)</option>
                                }
                            </select>
                            <svg class="metrics-selector-icon" viewBox="0 0 20 20" fill="currentColor">
                                <path d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z"/>
                            </svg>
                        </div>
                    }
                </div>

                @if (createMetricTypeValue == nameof(MetricType.Qualitative))
                {
                    <div class="form-row">
                        <label>Descrição do objetivo</label>
                        <InputText class="input" placeholder="Descreva o objetivo qualitativo desta métrica" @bind-Value="newMetric.TargetText" />
                    </div>
                }

                @if (createMetricTypeValue == nameof(MetricType.Quantitative) && !string.IsNullOrEmpty(createQuantitativeTypeValue))
                {
                    <div class="metrics-form-inputs">
                        <div class="metrics-input-field">
                            <select @bind="createMetricUnitValue">
                                <option value="">Unidade de medida</option>
                                @foreach (var unit in Enum.GetValues<MetricUnit>())
                                {
                                    <option value="@unit">@GetUnitLabel(unit)</option>
                                }
                            </select>
                        </div>

                        @if (createQuantitativeTypeValue == nameof(QuantitativeMetricType.KeepAbove) ||
                             createQuantitativeTypeValue == nameof(QuantitativeMetricType.KeepBetween))
                        {
                            <div class="metrics-input-field">
                                <InputNumber placeholder="Valor mínimo" @bind-Value="newMetric.MinValue" />
                            </div>
                        }

                        @if (createQuantitativeTypeValue == nameof(QuantitativeMetricType.KeepBelow) ||
                             createQuantitativeTypeValue == nameof(QuantitativeMetricType.KeepBetween) ||
                             createQuantitativeTypeValue == nameof(QuantitativeMetricType.Achieve) ||
                             createQuantitativeTypeValue == nameof(QuantitativeMetricType.Reduce))
                        {
                            <div class="metrics-input-field">
                                <InputNumber placeholder="@GetMaxValuePlaceholderForMetrics(createQuantitativeTypeValue)" @bind-Value="newMetric.MaxValue" />
                            </div>
                        }
                    </div>
                }
            </div>

            <div class="form-actions" style="margin-top: var(--spacing-6);">
                <button class="button tertiary" type="button" @onclick="CloseModal">Cancelar</button>
                <button class="button primary" type="submit">Criar métrica</button>
            </div>
        </EditForm>
    </Modal>
}

@if (isEditModalOpen && selectedMetric != null)
{
    <Modal Title="Editar métrica" OnClose="CloseEditMetricModal" Size="lg">
        <EditForm Model="@editMetric" OnValidSubmit="UpdateMetric">
            <DataAnnotationsValidator />
            <div class="metrics-form-container">
                <div class="metrics-form-header">
                    <div class="form-row">
                        <label>Nome da métrica</label>
                        <InputText class="input" @bind-Value="editMetric.Name" />
                    </div>
                </div>

                <div class="metrics-form-selectors">
                    <div class="metrics-selector-btn">
                        <svg class="metrics-selector-icon" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M4 6h12M4 10h12M4 14h12" stroke-linecap="round"/>
                        </svg>
                        <select value="@editMetricTypeValue" @onchange="OnEditMetricTypeChanged">
                            <option value="">Tipo de métrica</option>
                            @foreach (var metricType in Enum.GetValues<MetricType>())
                            {
                                <option value="@metricType">@GetMetricTypeLabel(metricType)</option>
                            }
                        </select>
                        <svg class="metrics-selector-icon" viewBox="0 0 20 20" fill="currentColor">
                            <path d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z"/>
                        </svg>
                    </div>

                    @if (editMetricTypeValue == nameof(MetricType.Quantitative))
                    {
                        <div class="metrics-selector-btn">
                            <svg class="metrics-selector-icon" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M3 10h14M10 3v14" stroke-linecap="round"/>
                            </svg>
                            <select @bind="editQuantitativeTypeValue">
                                <option value="">Modo de mensuração</option>
                                @foreach (var qType in Enum.GetValues<QuantitativeMetricType>())
                                {
                                    <option value="@qType">@GetQuantitativeTypeIcon(qType) @GetQuantitativeTypeLabel(qType)</option>
                                }
                            </select>
                            <svg class="metrics-selector-icon" viewBox="0 0 20 20" fill="currentColor">
                                <path d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z"/>
                            </svg>
                        </div>
                    }
                </div>

                @if (editMetricTypeValue == nameof(MetricType.Qualitative))
                {
                    <div class="form-row">
                        <label>Descrição do objetivo</label>
                        <InputText class="input" placeholder="Descreva o objetivo qualitativo desta métrica" @bind-Value="editMetric.TargetText" />
                    </div>
                }

                @if (editMetricTypeValue == nameof(MetricType.Quantitative) && !string.IsNullOrEmpty(editQuantitativeTypeValue))
                {
                    <div class="metrics-form-inputs">
                        <div class="metrics-input-field">
                            <select @bind="editMetricUnitValue">
                                <option value="">Unidade de medida</option>
                                @foreach (var unit in Enum.GetValues<MetricUnit>())
                                {
                                    <option value="@unit">@GetUnitLabel(unit)</option>
                                }
                            </select>
                        </div>

                        @if (editQuantitativeTypeValue == nameof(QuantitativeMetricType.KeepAbove) ||
                             editQuantitativeTypeValue == nameof(QuantitativeMetricType.KeepBetween))
                        {
                            <div class="metrics-input-field">
                                <InputNumber placeholder="Valor mínimo" @bind-Value="editMetric.MinValue" />
                            </div>
                        }

                        @if (editQuantitativeTypeValue == nameof(QuantitativeMetricType.KeepBelow) ||
                             editQuantitativeTypeValue == nameof(QuantitativeMetricType.KeepBetween) ||
                             editQuantitativeTypeValue == nameof(QuantitativeMetricType.Achieve) ||
                             editQuantitativeTypeValue == nameof(QuantitativeMetricType.Reduce))
                        {
                            <div class="metrics-input-field">
                                <InputNumber placeholder="@GetMaxValuePlaceholderForMetrics(editQuantitativeTypeValue)" @bind-Value="editMetric.MaxValue" />
                            </div>
                        }
                    </div>
                }
            </div>

            <div class="form-actions" style="margin-top: var(--spacing-6);">
                <button class="button tertiary" type="button" @onclick="CloseEditMetricModal">Cancelar</button>
                <button class="button primary" type="submit">Salvar alterações</button>
            </div>
        </EditForm>
    </Modal>
}

@code {
    private CreateMissionMetricRequest newMetric = new();
    private PagedResult<MissionMetric>? metrics;
    private Dictionary<Guid, MetricProgressDto> metricProgress = new();
    private List<Mission> missions = new();
    private string? createMissionId;
    private string? createMetricTypeValue;
    private string? createQuantitativeTypeValue;
    private string? createMetricUnitValue;
    private string? filterMissionId;
    private string? search;
    private bool isModalOpen = false;

    // Edit modal state
    private bool isEditModalOpen = false;
    private MissionMetric? selectedMetric = null;
    private UpdateMissionMetricRequest editMetric = new();
    private string? editMetricTypeValue;
    private string? editQuantitativeTypeValue;
    private string? editMetricUnitValue;

    // Delete confirmation
    private Guid? deletingMetricId = null;
    private System.Threading.Timer? deleteMetricConfirmTimer;

    protected override async Task OnInitializedAsync()
    {
        await LoadMissions();
        await LoadMetrics();
        OrgContext.OnOrganizationChanged += HandleOrganizationChanged;
    }

    private void HandleOrganizationChanged()
    {
        _ = HandleOrganizationChangedAsync();
    }

    private async Task HandleOrganizationChangedAsync()
    {
        try
        {
            await InvokeAsync(async () =>
            {
                filterMissionId = null;
                await LoadMissions();
                await LoadMetrics();
                StateHasChanged();
            });
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Erro ao atualizar métricas por troca de organização: {ex.Message}");
            ToastService.ShowError("Erro ao atualizar métricas", "Não foi possível atualizar os dados da organização selecionada.");
        }
    }

    public void Dispose()
    {
        OrgContext.OnOrganizationChanged -= HandleOrganizationChanged;
        deleteMetricConfirmTimer?.Dispose();
    }

    private async Task LoadMissions()
    {
        try
        {
            var result = await Api.GetMissionsAsync(null, null, null, 1, 100);
            missions = result?.Items.ToList() ?? new List<Mission>();
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Erro ao carregar missões para métricas: {ex.Message}");
            missions = new List<Mission>();
            ToastService.ShowError("Erro ao carregar missões", "Não foi possível carregar as missões.");
        }
    }

    private async Task LoadMetrics()
    {
        try
        {
            var missionId = Guid.TryParse(filterMissionId, out var parsedMissionId)
                ? parsedMissionId
                : (Guid?)null;

            metrics = await Api.GetMissionMetricsAsync(missionId, search, 1, 20) ?? new PagedResult<MissionMetric>();
            await LoadMetricProgress();
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Erro ao carregar métricas: {ex.Message}");
            metrics = new PagedResult<MissionMetric>();
            metricProgress = new();
            ToastService.ShowError("Erro ao carregar métricas", "Não foi possível carregar as métricas.");
        }
    }

    private async Task LoadMetricProgress()
    {
        if (metrics is null || metrics.Items.Count == 0)
        {
            metricProgress = new();
            return;
        }

        try
        {
            var ids = metrics.Items.Select(m => m.Id).ToList();
            var progressList = await Api.GetMetricProgressAsync(ids);
            metricProgress = progressList?.ToDictionary(p => p.MetricId) ?? new();
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Erro ao carregar progresso das métricas: {ex.Message}");
            metricProgress = new();
        }
    }

    private async Task OnMetricTypeChanged(ChangeEventArgs e)
    {
        createMetricTypeValue = e.Value?.ToString();
        newMetric.TargetText = null;
        newMetric.MinValue = null;
        newMetric.MaxValue = null;
        newMetric.QuantitativeType = null;
        createQuantitativeTypeValue = null;
        createMetricUnitValue = null;
        await InvokeAsync(StateHasChanged);
    }

    private void OpenCreateModal()
    {
        newMetric = new CreateMissionMetricRequest();
        createMissionId = null;
        createMetricTypeValue = null;
        createQuantitativeTypeValue = null;
        createMetricUnitValue = null;
        isModalOpen = true;
    }

    private void CloseModal()
    {
        isModalOpen = false;
    }

    private async Task CreateMetric()
    {
        const string errorTitle = "Erro ao criar métrica";

        if (!TryPrepareMetricForCreate(errorTitle, out _))
        {
            return;
        }

        await UiOps.RunAsync(
            async () =>
            {
                await Api.CreateMissionMetricAsync(newMetric);
                var createdMetricName = newMetric.Name;
                ResetCreateMetricForm();
                await LoadMetrics();

                ToastService.ShowSuccess("Métrica criada com sucesso!", $"A métrica '{createdMetricName}' foi criada.");
                CloseModal();
            },
            errorTitle,
            "Não foi possível criar a métrica. Verifique os dados e tente novamente.");
    }

    private bool TryPrepareMetricForCreate(string errorTitle, out MetricType metricType)
    {
        metricType = default;

        if (!Guid.TryParse(createMissionId, out var missionId))
        {
            ToastService.ShowError(errorTitle, "Selecione uma missão.");
            return false;
        }

        if (string.IsNullOrWhiteSpace(newMetric.Name))
        {
            ToastService.ShowError(errorTitle, "Informe o nome da métrica.");
            return false;
        }

        if (!TryParseMetricType(createMetricTypeValue, errorTitle, "Selecione o tipo da metrica.", out metricType))
        {
            return false;
        }

        newMetric.MissionId = missionId;
        newMetric.Type = metricType;

        if (metricType == MetricType.Qualitative)
        {
            if (string.IsNullOrWhiteSpace(newMetric.TargetText))
            {
                ToastService.ShowError(errorTitle, "Informe o texto alvo.");
                return false;
            }

            return true;
        }

        return TryPrepareQuantitativeMetricForCreate(errorTitle);
    }

    private bool TryPrepareQuantitativeMetricForCreate(string errorTitle)
    {
        if (!Enum.TryParse<QuantitativeMetricType>(createQuantitativeTypeValue, out var quantitativeType))
        {
            ToastService.ShowError(errorTitle, "Selecione o tipo de métrica quantitativa.");
            return false;
        }

        newMetric.QuantitativeType = quantitativeType;

        if (quantitativeType == QuantitativeMetricType.KeepAbove && newMetric.MinValue is null)
        {
            ToastService.ShowError(errorTitle, "Informe o valor mínimo.");
            return false;
        }

        if (quantitativeType == QuantitativeMetricType.KeepBelow && newMetric.MaxValue is null)
        {
            ToastService.ShowError(errorTitle, "Informe o valor máximo.");
            return false;
        }

        if (quantitativeType == QuantitativeMetricType.KeepBetween)
        {
            if (newMetric.MinValue is null || newMetric.MaxValue is null)
            {
                ToastService.ShowError(errorTitle, "Informe os valores mínimo e máximo.");
                return false;
            }

            if (newMetric.MinValue >= newMetric.MaxValue)
            {
                ToastService.ShowError(errorTitle, "O valor mínimo deve ser menor que o valor máximo.");
                return false;
            }
        }

        if ((quantitativeType == QuantitativeMetricType.Achieve || quantitativeType == QuantitativeMetricType.Reduce) &&
            newMetric.MaxValue is null)
        {
            ToastService.ShowError(errorTitle, "Informe o valor alvo.");
            return false;
        }

        if (!Enum.TryParse<MetricUnit>(createMetricUnitValue, out var metricUnit))
        {
            ToastService.ShowError(errorTitle, "Selecione a unidade.");
            return false;
        }

        newMetric.Unit = metricUnit;
        return true;
    }

    private bool TryParseMetricType(
        string? metricTypeValue,
        string errorTitle,
        string errorMessage,
        out MetricType metricType)
    {
        if (!Enum.TryParse(metricTypeValue, out metricType))
        {
            ToastService.ShowError(errorTitle, errorMessage);
            return false;
        }

        return true;
    }

    private void ResetCreateMetricForm()
    {
        newMetric = new CreateMissionMetricRequest();
        createMissionId = null;
        createMetricTypeValue = null;
        createQuantitativeTypeValue = null;
        createMetricUnitValue = null;
    }

    private string GetMissionName(Guid missionId)
    {
        return missions.FirstOrDefault(m => m.Id == missionId)?.Name ?? "—";
    }

    private static string GetMetricTypeLabel(MetricType type) => MissionMetricDisplayHelper.GetMetricTypeLabel(type);

    private static string GetQuantitativeTypeLabel(QuantitativeMetricType type) => MissionMetricDisplayHelper.GetQuantitativeTypeLabel(type);

    private static string GetQuantitativeTypeIcon(QuantitativeMetricType type) => MissionMetricDisplayHelper.GetQuantitativeTypeIcon(type);

    private static string GetUnitLabel(MetricUnit unit) => MissionMetricDisplayHelper.GetUnitLabel(unit);

    private static string GetTargetLabel(MissionMetric metric) => MissionMetricDisplayHelper.GetTargetLabel(metric);

    private static string GetMaxValuePlaceholderForMetrics(string? quantitativeType) => quantitativeType switch
    {
        nameof(QuantitativeMetricType.KeepBelow) => "Valor máximo",
        nameof(QuantitativeMetricType.KeepBetween) => "Valor máximo",
        nameof(QuantitativeMetricType.Achieve) => "Valor alvo",
        nameof(QuantitativeMetricType.Reduce) => "Valor alvo",
        _ => "Valor máximo"
    };

    // ---- Edit Methods ----

    private void OpenEditMetricModal(MissionMetric metric)
    {
        selectedMetric = metric;
        editMetric = new UpdateMissionMetricRequest
        {
            Name = metric.Name,
            Type = metric.Type,
            QuantitativeType = metric.QuantitativeType,
            MinValue = metric.MinValue,
            MaxValue = metric.MaxValue,
            Unit = metric.Unit,
            TargetText = metric.TargetText
        };
        editMetricTypeValue = metric.Type.ToString();
        editQuantitativeTypeValue = metric.QuantitativeType?.ToString();
        editMetricUnitValue = metric.Unit?.ToString();
        isEditModalOpen = true;
    }

    private void CloseEditMetricModal()
    {
        isEditModalOpen = false;
        selectedMetric = null;
        editMetric = new();
        editMetricTypeValue = null;
        editQuantitativeTypeValue = null;
        editMetricUnitValue = null;
    }

    private async Task UpdateMetric()
    {
        if (selectedMetric == null) return;

        if (!TryParseMetricType(editMetricTypeValue, "Erro ao atualizar métrica", "Selecione o tipo da métrica.", out var metricType))
        {
            return;
        }

        editMetric.Type = metricType;

        if (metricType == MetricType.Quantitative)
        {
            if (Enum.TryParse<QuantitativeMetricType>(editQuantitativeTypeValue, out var qType))
                editMetric.QuantitativeType = qType;
            if (Enum.TryParse<MetricUnit>(editMetricUnitValue, out var unit))
                editMetric.Unit = unit;
        }

        await UiOps.RunAsync(
            async () =>
            {
                await Api.UpdateMissionMetricAsync(selectedMetric.Id, editMetric);
                ToastService.ShowSuccess("Métrica atualizada", "As alterações foram salvas com sucesso.");
                CloseEditMetricModal();
                await LoadMetrics();
            },
            "Erro ao atualizar",
            "Não foi possível atualizar a métrica. Verifique os dados e tente novamente.");
    }

    private async Task OnEditMetricTypeChanged(ChangeEventArgs e)
    {
        editMetricTypeValue = e.Value?.ToString();
        editMetric.TargetText = null;
        editMetric.MinValue = null;
        editMetric.MaxValue = null;
        editMetric.QuantitativeType = null;
        editQuantitativeTypeValue = null;
        editMetricUnitValue = null;
        await InvokeAsync(StateHasChanged);
    }

    // ---- Progress & Confidence Helpers ----

    private static string GetProgressStatusClass(MetricProgressDto progress) => MissionProgressDisplayHelper.GetMetricProgressStatusClass(progress);

    private static (string statusClass, string label) GetConfidenceDisplay(int confidence) => MissionProgressDisplayHelper.GetConfidenceDisplay(confidence);

    private static string GetConfidenceStarsText(int confidence) => MissionProgressDisplayHelper.GetConfidenceStarsText(confidence);

    // ---- Delete Methods ----

    private async Task HandleDeleteMetricClick(Guid metricId)
    {
        if (deletingMetricId == metricId)
        {
            await DeleteMetric(metricId);
        }
        else
        {
            ArmMetricDeleteConfirmation(metricId);
        }
    }

    private async Task DeleteMetric(Guid metricId)
    {
        try
        {
            await UiOps.RunAsync(
                async () =>
                {
                    await Api.DeleteMissionMetricAsync(metricId);
                    ToastService.ShowSuccess("Métrica excluída", "A métrica foi removida com sucesso.");
                    await LoadMetrics();
                },
                "Erro ao excluir",
                "Não foi possível excluir a métrica. Tente novamente.");
        }
        finally
        {
            ClearMetricDeleteConfirmation();
        }
    }

    private void ArmMetricDeleteConfirmation(Guid metricId)
    {
        deletingMetricId = metricId;
        deleteMetricConfirmTimer?.Dispose();
        deleteMetricConfirmTimer = new System.Threading.Timer(
            _ => InvokeAsync(() =>
            {
                deletingMetricId = null;
                StateHasChanged();
            }),
            null,
            3000,
            Timeout.Infinite);
    }

    private void ClearMetricDeleteConfirmation()
    {
        deletingMetricId = null;
        deleteMetricConfirmTimer?.Dispose();
        deleteMetricConfirmTimer = null;
    }
}
