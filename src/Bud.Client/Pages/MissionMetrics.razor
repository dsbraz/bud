@page "/mission-metrics"
@inject ApiClient Api
@inject ToastService ToastService
@inject OrganizationContext OrgContext
@implements IDisposable

<MissionsMenu />

<div class="page-header">
    <div>
        <div class="page-kicker">Gestão</div>
        <h1>Métricas</h1>
        <p class="page-subtitle">Defina métricas para suas missões.</p>
    </div>
    <button class="button primary" @onclick="OpenCreateModal">
        <span class="button-icon-text">+</span>
        Nova métrica
    </button>
</div>

<div class="card">
    <div class="card-filters">
        <div class="form-row">
            <label>Missão</label>
            <select class="input" @bind="filterMissionId" @bind:after="LoadMetrics">
                <option value="">Todas</option>
                @foreach (var mission in missions)
                {
                    <option value="@mission.Id">@mission.Name</option>
                }
            </select>
        </div>
        <div class="form-row">
            <label>Busca</label>
            <InputText class="input" @bind-Value="search" />
        </div>
        <div class="form-row" style="align-self: flex-end;">
            <button class="button" @onclick="LoadMetrics">Atualizar</button>
        </div>
    </div>

    @if (metrics is null)
    {
        <p class="muted">Carregando...</p>
    }
    else if (metrics.Items.Count == 0)
    {
        <p class="muted">Nenhuma métrica encontrada.</p>
    }
    else
    {
        <table class="table">
            <thead>
                <tr>
                    <th>Nome</th>
                    <th>Tipo</th>
                    <th>Alvo</th>
                    <th>Progresso</th>
                    <th>Confiança</th>
                    <th>Missão</th>
                    <th style="width: 120px; text-align: center;">Ações</th>
                </tr>
            </thead>
            <tbody>
                @foreach (var metric in metrics.Items)
                {
                    var isDeleting = deletingMetricId == metric.Id;
                    var progress = metricProgress.GetValueOrDefault(metric.Id);
                    <tr>
                        <td>@metric.Name</td>
                        <td>@GetMetricTypeLabel(metric.Type)</td>
                        <td>@GetTargetLabel(metric)</td>
                        <td>
                            @if (progress is null || !progress.HasCheckins)
                            {
                                <span class="muted">—</span>
                            }
                            else
                            {
                                var statusClass = GetProgressStatusClass(progress);
                                <div class="mission-progress">
                                    <div class="progress-bar">
                                        <div class="progress-fill @statusClass" style="width: @($"{progress.Progress:F0}%")"></div>
                                    </div>
                                    <span class="progress-label">@($"{progress.Progress:F0}%")</span>
                                </div>
                            }
                        </td>
                        <td>
                            @if (progress is null || !progress.HasCheckins)
                            {
                                <span class="confidence-badge no-data">Sem dados</span>
                            }
                            else
                            {
                                var (confClass, confLabel) = GetConfidenceDisplay(progress.Confidence);
                                <span class="confidence-badge @confClass">@GetConfidenceStarsText(progress.Confidence) @confLabel</span>
                            }
                        </td>
                        <td>@GetMissionName(metric.MissionId)</td>
                        <td style="text-align: center;">
                            <div class="table-actions">
                                <button class="button-icon" @onclick="() => OpenEditMetricModal(metric)"
                                        title="Editar métrica">
                                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                                        <path d="M11.334 2.00004C11.5091 1.82494 11.7169 1.68605 11.9457 1.59129C12.1745 1.49653 12.4197 1.44775 12.6673 1.44775C12.9149 1.44775 13.1601 1.49653 13.3889 1.59129C13.6177 1.68605 13.8256 1.82494 14.0007 2.00004C14.1758 2.17513 14.3147 2.383 14.4094 2.61178C14.5042 2.84055 14.553 3.08575 14.553 3.33337C14.553 3.58099 14.5042 3.82619 14.4094 4.05497C14.3147 4.28374 14.1758 4.49161 14.0007 4.66671L5.00065 13.6667L1.33398 14.6667L2.33398 11L11.334 2.00004Z" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                                    </svg>
                                </button>
                                <button class="button-icon @(isDeleting ? "danger" : "")"
                                        @onclick="() => HandleDeleteMetricClick(metric.Id)"
                                        title="@(isDeleting ? "Clique novamente para confirmar" : "Excluir métrica")">
                                    @if (isDeleting)
                                    {
                                        <span style="font-size: 11px; white-space: nowrap;">Confirmar?</span>
                                    }
                                    else
                                    {
                                        <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                                            <path d="M2 4H3.33333H14" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                                            <path d="M5.33398 4.00004V2.66671C5.33398 2.31309 5.47446 1.97395 5.72451 1.7239C5.97456 1.47385 6.3137 1.33337 6.66732 1.33337H9.33398C9.6876 1.33337 10.0268 1.47385 10.2768 1.7239C10.5269 1.97395 10.6673 2.31309 10.6673 2.66671V4.00004M12.6673 4.00004V13.3334C12.6673 13.687 12.5269 14.0261 12.2768 14.2762C12.0268 14.5262 11.6876 14.6667 11.334 14.6667H4.66732C4.3137 14.6667 3.97456 14.5262 3.72451 14.2762C3.47446 14.0261 3.33398 13.687 3.33398 13.3334V4.00004H12.6673Z" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                                        </svg>
                                    }
                                </button>
                            </div>
                        </td>
                    </tr>
                }
            </tbody>
        </table>
        <p class="muted" style="margin-top: var(--spacing-4);">Total: @metrics.Total</p>
    }
</div>

@if (isModalOpen)
{
    <Modal Title="Nova métrica" OnClose="CloseModal" Size="lg">
        <EditForm Model="@newMetric" OnValidSubmit="CreateMetric">
            <DataAnnotationsValidator />
            <div class="metrics-form-container">
                <div class="metrics-form-header">
                    <div class="form-row">
                        <label>Missão</label>
                        <select class="input" @bind="createMissionId">
                            <option value="">Selecione uma missão</option>
                            @foreach (var mission in missions)
                            {
                                <option value="@mission.Id">@mission.Name</option>
                            }
                        </select>
                    </div>
                    <div class="form-row">
                        <label>Nome da métrica</label>
                        <InputText class="input" placeholder="Ex: Taxa de conversão, NPS, etc." @bind-Value="newMetric.Name" />
                    </div>
                </div>

                <div class="metrics-form-selectors">
                    <div class="metrics-selector-btn">
                        <svg class="metrics-selector-icon" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M4 6h12M4 10h12M4 14h12" stroke-linecap="round"/>
                        </svg>
                        <select value="@createMetricTypeValue" @onchange="OnMetricTypeChanged">
                            <option value="">Tipo de métrica</option>
                            @foreach (var metricType in Enum.GetValues<MetricType>())
                            {
                                <option value="@metricType">@GetMetricTypeLabel(metricType)</option>
                            }
                        </select>
                        <svg class="metrics-selector-icon" viewBox="0 0 20 20" fill="currentColor">
                            <path d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z"/>
                        </svg>
                    </div>

                    @if (createMetricTypeValue == nameof(MetricType.Quantitative))
                    {
                        <div class="metrics-selector-btn">
                            <svg class="metrics-selector-icon" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M3 10h14M10 3v14" stroke-linecap="round"/>
                            </svg>
                            <select @bind="createQuantitativeTypeValue">
                                <option value="">Modo de mensuração</option>
                                @foreach (var qType in Enum.GetValues<QuantitativeMetricType>())
                                {
                                    <option value="@qType">@GetQuantitativeTypeIcon(qType) @GetQuantitativeTypeLabel(qType)</option>
                                }
                            </select>
                            <svg class="metrics-selector-icon" viewBox="0 0 20 20" fill="currentColor">
                                <path d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z"/>
                            </svg>
                        </div>
                    }
                </div>

                @if (createMetricTypeValue == nameof(MetricType.Qualitative))
                {
                    <div class="form-row">
                        <label>Descrição do objetivo</label>
                        <InputText class="input" placeholder="Descreva o objetivo qualitativo desta métrica" @bind-Value="newMetric.TargetText" />
                    </div>
                }

                @if (createMetricTypeValue == nameof(MetricType.Quantitative) && !string.IsNullOrEmpty(createQuantitativeTypeValue))
                {
                    <div class="metrics-form-inputs">
                        <div class="metrics-input-field">
                            <select @bind="createMetricUnitValue">
                                <option value="">Unidade de medida</option>
                                @foreach (var unit in Enum.GetValues<MetricUnit>())
                                {
                                    <option value="@unit">@GetUnitLabel(unit)</option>
                                }
                            </select>
                        </div>

                        @if (createQuantitativeTypeValue == nameof(QuantitativeMetricType.KeepAbove) ||
                             createQuantitativeTypeValue == nameof(QuantitativeMetricType.KeepBetween))
                        {
                            <div class="metrics-input-field">
                                <InputNumber placeholder="Valor mínimo" @bind-Value="newMetric.MinValue" />
                            </div>
                        }

                        @if (createQuantitativeTypeValue == nameof(QuantitativeMetricType.KeepBelow) ||
                             createQuantitativeTypeValue == nameof(QuantitativeMetricType.KeepBetween) ||
                             createQuantitativeTypeValue == nameof(QuantitativeMetricType.Achieve) ||
                             createQuantitativeTypeValue == nameof(QuantitativeMetricType.Reduce))
                        {
                            <div class="metrics-input-field">
                                <InputNumber placeholder="@GetMaxValuePlaceholderForMetrics(createQuantitativeTypeValue)" @bind-Value="newMetric.MaxValue" />
                            </div>
                        }
                    </div>
                }
            </div>

            <div class="form-actions" style="margin-top: var(--spacing-6);">
                <button class="button tertiary" type="button" @onclick="CloseModal">Cancelar</button>
                <button class="button primary" type="submit">Criar métrica</button>
            </div>
        </EditForm>
    </Modal>
}

@if (isEditModalOpen && selectedMetric != null)
{
    <Modal Title="Editar métrica" OnClose="CloseEditMetricModal" Size="lg">
        <EditForm Model="@editMetric" OnValidSubmit="UpdateMetric">
            <DataAnnotationsValidator />
            <div class="metrics-form-container">
                <div class="metrics-form-header">
                    <div class="form-row">
                        <label>Nome da métrica</label>
                        <InputText class="input" @bind-Value="editMetric.Name" />
                    </div>
                </div>

                <div class="metrics-form-selectors">
                    <div class="metrics-selector-btn">
                        <svg class="metrics-selector-icon" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M4 6h12M4 10h12M4 14h12" stroke-linecap="round"/>
                        </svg>
                        <select value="@editMetricTypeValue" @onchange="OnEditMetricTypeChanged">
                            <option value="">Tipo de métrica</option>
                            @foreach (var metricType in Enum.GetValues<MetricType>())
                            {
                                <option value="@metricType">@GetMetricTypeLabel(metricType)</option>
                            }
                        </select>
                        <svg class="metrics-selector-icon" viewBox="0 0 20 20" fill="currentColor">
                            <path d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z"/>
                        </svg>
                    </div>

                    @if (editMetricTypeValue == nameof(MetricType.Quantitative))
                    {
                        <div class="metrics-selector-btn">
                            <svg class="metrics-selector-icon" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M3 10h14M10 3v14" stroke-linecap="round"/>
                            </svg>
                            <select @bind="editQuantitativeTypeValue">
                                <option value="">Modo de mensuração</option>
                                @foreach (var qType in Enum.GetValues<QuantitativeMetricType>())
                                {
                                    <option value="@qType">@GetQuantitativeTypeIcon(qType) @GetQuantitativeTypeLabel(qType)</option>
                                }
                            </select>
                            <svg class="metrics-selector-icon" viewBox="0 0 20 20" fill="currentColor">
                                <path d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z"/>
                            </svg>
                        </div>
                    }
                </div>

                @if (editMetricTypeValue == nameof(MetricType.Qualitative))
                {
                    <div class="form-row">
                        <label>Descrição do objetivo</label>
                        <InputText class="input" placeholder="Descreva o objetivo qualitativo desta métrica" @bind-Value="editMetric.TargetText" />
                    </div>
                }

                @if (editMetricTypeValue == nameof(MetricType.Quantitative) && !string.IsNullOrEmpty(editQuantitativeTypeValue))
                {
                    <div class="metrics-form-inputs">
                        <div class="metrics-input-field">
                            <select @bind="editMetricUnitValue">
                                <option value="">Unidade de medida</option>
                                @foreach (var unit in Enum.GetValues<MetricUnit>())
                                {
                                    <option value="@unit">@GetUnitLabel(unit)</option>
                                }
                            </select>
                        </div>

                        @if (editQuantitativeTypeValue == nameof(QuantitativeMetricType.KeepAbove) ||
                             editQuantitativeTypeValue == nameof(QuantitativeMetricType.KeepBetween))
                        {
                            <div class="metrics-input-field">
                                <InputNumber placeholder="Valor mínimo" @bind-Value="editMetric.MinValue" />
                            </div>
                        }

                        @if (editQuantitativeTypeValue == nameof(QuantitativeMetricType.KeepBelow) ||
                             editQuantitativeTypeValue == nameof(QuantitativeMetricType.KeepBetween) ||
                             editQuantitativeTypeValue == nameof(QuantitativeMetricType.Achieve) ||
                             editQuantitativeTypeValue == nameof(QuantitativeMetricType.Reduce))
                        {
                            <div class="metrics-input-field">
                                <InputNumber placeholder="@GetMaxValuePlaceholderForMetrics(editQuantitativeTypeValue)" @bind-Value="editMetric.MaxValue" />
                            </div>
                        }
                    </div>
                }
            </div>

            <div class="form-actions" style="margin-top: var(--spacing-6);">
                <button class="button tertiary" type="button" @onclick="CloseEditMetricModal">Cancelar</button>
                <button class="button primary" type="submit">Salvar alterações</button>
            </div>
        </EditForm>
    </Modal>
}

@code {
    private CreateMissionMetricRequest newMetric = new();
    private PagedResult<MissionMetric>? metrics;
    private Dictionary<Guid, MetricProgressDto> metricProgress = new();
    private List<Mission> missions = new();
    private string? createMissionId;
    private string? createMetricTypeValue;
    private string? createQuantitativeTypeValue;
    private string? createMetricUnitValue;
    private string? filterMissionId;
    private string? search;
    private bool isModalOpen = false;

    // Edit modal state
    private bool isEditModalOpen = false;
    private MissionMetric? selectedMetric = null;
    private UpdateMissionMetricRequest editMetric = new();
    private string? editMetricTypeValue;
    private string? editQuantitativeTypeValue;
    private string? editMetricUnitValue;

    // Delete confirmation
    private Guid? deletingMetricId = null;
    private System.Threading.Timer? deleteMetricConfirmTimer;

    protected override async Task OnInitializedAsync()
    {
        await LoadMissions();
        await LoadMetrics();
        OrgContext.OnOrganizationChanged += HandleOrganizationChanged;
    }

    private void HandleOrganizationChanged()
    {
        _ = HandleOrganizationChangedAsync();
    }

    private async Task HandleOrganizationChangedAsync()
    {
        try
        {
            await InvokeAsync(async () =>
            {
                filterMissionId = null;
                await LoadMissions();
                await LoadMetrics();
                StateHasChanged();
            });
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Erro ao atualizar métricas por troca de organização: {ex.Message}");
            ToastService.ShowError("Erro ao atualizar métricas", "Não foi possível atualizar os dados da organização selecionada.");
        }
    }

    public void Dispose()
    {
        OrgContext.OnOrganizationChanged -= HandleOrganizationChanged;
        deleteMetricConfirmTimer?.Dispose();
    }

    private async Task LoadMissions()
    {
        try
        {
            var result = await Api.GetMissionsAsync(null, null, null, 1, 100);
            missions = result?.Items.ToList() ?? new List<Mission>();
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Erro ao carregar missões para métricas: {ex.Message}");
            missions = new List<Mission>();
            ToastService.ShowError("Erro ao carregar missões", "Não foi possível carregar as missões.");
        }
    }

    private async Task LoadMetrics()
    {
        try
        {
            var missionId = Guid.TryParse(filterMissionId, out var parsedMissionId)
                ? parsedMissionId
                : (Guid?)null;

            metrics = await Api.GetMissionMetricsAsync(missionId, search, 1, 20) ?? new PagedResult<MissionMetric>();
            await LoadMetricProgress();
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Erro ao carregar métricas: {ex.Message}");
            metrics = new PagedResult<MissionMetric>();
            metricProgress = new();
            ToastService.ShowError("Erro ao carregar métricas", "Não foi possível carregar as métricas.");
        }
    }

    private async Task LoadMetricProgress()
    {
        if (metrics is null || metrics.Items.Count == 0)
        {
            metricProgress = new();
            return;
        }

        try
        {
            var ids = metrics.Items.Select(m => m.Id).ToList();
            var progressList = await Api.GetMetricProgressAsync(ids);
            metricProgress = progressList?.ToDictionary(p => p.MetricId) ?? new();
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Erro ao carregar progresso das métricas: {ex.Message}");
            metricProgress = new();
        }
    }

    private async Task OnMetricTypeChanged(ChangeEventArgs e)
    {
        createMetricTypeValue = e.Value?.ToString();
        newMetric.TargetText = null;
        newMetric.MinValue = null;
        newMetric.MaxValue = null;
        newMetric.QuantitativeType = null;
        createQuantitativeTypeValue = null;
        createMetricUnitValue = null;
        await InvokeAsync(StateHasChanged);
    }

    private void OpenCreateModal()
    {
        newMetric = new CreateMissionMetricRequest();
        createMissionId = null;
        createMetricTypeValue = null;
        createQuantitativeTypeValue = null;
        createMetricUnitValue = null;
        isModalOpen = true;
    }

    private void CloseModal()
    {
        isModalOpen = false;
    }

    private async Task CreateMetric()
    {
        if (!Guid.TryParse(createMissionId, out var missionId))
        {
            ToastService.ShowError("Erro ao criar métrica", "Selecione uma missão.");
            return;
        }

        if (string.IsNullOrWhiteSpace(newMetric.Name))
        {
            ToastService.ShowError("Erro ao criar métrica", "Informe o nome da métrica.");
            return;
        }

        if (!Enum.TryParse<MetricType>(createMetricTypeValue, out var metricType))
        {
            ToastService.ShowError("Erro ao criar métrica", "Selecione o tipo da metrica.");
            return;
        }

        newMetric.MissionId = missionId;
        newMetric.Type = metricType;

        if (metricType == MetricType.Qualitative)
        {
            if (string.IsNullOrWhiteSpace(newMetric.TargetText))
            {
                ToastService.ShowError("Erro ao criar métrica", "Informe o texto alvo.");
                return;
            }
        }
        else
        {
            if (!Enum.TryParse<QuantitativeMetricType>(createQuantitativeTypeValue, out var quantitativeType))
            {
                ToastService.ShowError("Erro ao criar métrica", "Selecione o tipo de métrica quantitativa.");
                return;
            }

            newMetric.QuantitativeType = quantitativeType;

            if (quantitativeType == QuantitativeMetricType.KeepAbove && newMetric.MinValue is null)
            {
                ToastService.ShowError("Erro ao criar métrica", "Informe o valor mínimo.");
                return;
            }

            if (quantitativeType == QuantitativeMetricType.KeepBelow && newMetric.MaxValue is null)
            {
                ToastService.ShowError("Erro ao criar métrica", "Informe o valor máximo.");
                return;
            }

            if (quantitativeType == QuantitativeMetricType.KeepBetween)
            {
                if (newMetric.MinValue is null || newMetric.MaxValue is null)
                {
                    ToastService.ShowError("Erro ao criar métrica", "Informe os valores mínimo e máximo.");
                    return;
                }

                if (newMetric.MinValue >= newMetric.MaxValue)
                {
                    ToastService.ShowError("Erro ao criar métrica", "O valor mínimo deve ser menor que o valor máximo.");
                    return;
                }
            }

            if (quantitativeType == QuantitativeMetricType.Achieve && newMetric.MaxValue is null)
            {
                ToastService.ShowError("Erro ao criar métrica", "Informe o valor alvo.");
                return;
            }

            if (quantitativeType == QuantitativeMetricType.Reduce && newMetric.MaxValue is null)
            {
                ToastService.ShowError("Erro ao criar métrica", "Informe o valor alvo.");
                return;
            }

            if (!Enum.TryParse<MetricUnit>(createMetricUnitValue, out var metricUnit))
            {
                ToastService.ShowError("Erro ao criar métrica", "Selecione a unidade.");
                return;
            }

            newMetric.Unit = metricUnit;
        }

        await Api.CreateMissionMetricAsync(newMetric);
        var createdMetricName = newMetric.Name;
        newMetric = new CreateMissionMetricRequest();
        createMissionId = null;
        createMetricTypeValue = null;
        createQuantitativeTypeValue = null;
        createMetricUnitValue = null;
        await LoadMetrics();

        ToastService.ShowSuccess("Métrica criada com sucesso!", $"A métrica '{createdMetricName}' foi criada.");
        CloseModal();
    }

    private string GetMissionName(Guid missionId)
    {
        return missions.FirstOrDefault(m => m.Id == missionId)?.Name ?? "—";
    }

    private static string GetMetricTypeLabel(MetricType type) => type switch
    {
        MetricType.Qualitative => "Qualitativa",
        MetricType.Quantitative => "Quantitativa",
        _ => type.ToString()
    };

    private static string GetQuantitativeTypeLabel(QuantitativeMetricType type) => type switch
    {
        QuantitativeMetricType.KeepAbove => "Manter acima",
        QuantitativeMetricType.KeepBelow => "Manter abaixo",
        QuantitativeMetricType.KeepBetween => "Manter entre",
        QuantitativeMetricType.Achieve => "Atingir",
        QuantitativeMetricType.Reduce => "Reduzir",
        _ => type.ToString()
    };

    private static string GetQuantitativeTypeIcon(QuantitativeMetricType type) => type switch
    {
        QuantitativeMetricType.KeepAbove => "↑",
        QuantitativeMetricType.KeepBelow => "↓",
        QuantitativeMetricType.KeepBetween => "↕",
        QuantitativeMetricType.Achieve => "→",
        QuantitativeMetricType.Reduce => "↘",
        _ => ""
    };

    private static string GetUnitLabel(MetricUnit unit) => unit switch
    {
        MetricUnit.Integer => "Inteiro",
        MetricUnit.Decimal => "Decimal",
        MetricUnit.Percentage => "Percentual",
        MetricUnit.Hours => "Horas",
        MetricUnit.Points => "Pontos",
        _ => unit.ToString()
    };

    private static string GetTargetLabel(MissionMetric metric)
    {
        if (metric.Type == MetricType.Qualitative)
        {
            return metric.TargetText ?? "—";
        }

        var unit = metric.Unit.HasValue ? GetUnitLabel(metric.Unit.Value) : "";
        var quantType = metric.QuantitativeType.HasValue ? GetQuantitativeTypeLabel(metric.QuantitativeType.Value) : "—";

        return metric.QuantitativeType switch
        {
            QuantitativeMetricType.KeepAbove => $"{quantType} {metric.MinValue} {unit}",
            QuantitativeMetricType.KeepBelow => $"{quantType} {metric.MaxValue} {unit}",
            QuantitativeMetricType.KeepBetween => $"{quantType} {metric.MinValue} e {metric.MaxValue} {unit}",
            QuantitativeMetricType.Achieve => $"{quantType} {metric.MaxValue} {unit}",
            QuantitativeMetricType.Reduce => $"{quantType} para {metric.MaxValue} {unit}",
            _ => "—"
        };
    }

    private static string GetMaxValuePlaceholderForMetrics(string? quantitativeType) => quantitativeType switch
    {
        nameof(QuantitativeMetricType.KeepBelow) => "Valor máximo",
        nameof(QuantitativeMetricType.KeepBetween) => "Valor máximo",
        nameof(QuantitativeMetricType.Achieve) => "Valor alvo",
        nameof(QuantitativeMetricType.Reduce) => "Valor alvo",
        _ => "Valor máximo"
    };

    // ---- Edit Methods ----

    private void OpenEditMetricModal(MissionMetric metric)
    {
        selectedMetric = metric;
        editMetric = new UpdateMissionMetricRequest
        {
            Name = metric.Name,
            Type = metric.Type,
            QuantitativeType = metric.QuantitativeType,
            MinValue = metric.MinValue,
            MaxValue = metric.MaxValue,
            Unit = metric.Unit,
            TargetText = metric.TargetText
        };
        editMetricTypeValue = metric.Type.ToString();
        editQuantitativeTypeValue = metric.QuantitativeType?.ToString();
        editMetricUnitValue = metric.Unit?.ToString();
        isEditModalOpen = true;
    }

    private void CloseEditMetricModal()
    {
        isEditModalOpen = false;
        selectedMetric = null;
        editMetric = new();
        editMetricTypeValue = null;
        editQuantitativeTypeValue = null;
        editMetricUnitValue = null;
    }

    private async Task UpdateMetric()
    {
        if (selectedMetric == null) return;

        if (!Enum.TryParse<MetricType>(editMetricTypeValue, out var metricType))
        {
            ToastService.ShowError("Erro ao atualizar métrica", "Selecione o tipo da métrica.");
            return;
        }

        editMetric.Type = metricType;

        if (metricType == MetricType.Quantitative)
        {
            if (Enum.TryParse<QuantitativeMetricType>(editQuantitativeTypeValue, out var qType))
                editMetric.QuantitativeType = qType;
            if (Enum.TryParse<MetricUnit>(editMetricUnitValue, out var unit))
                editMetric.Unit = unit;
        }

        try
        {
            await Api.UpdateMissionMetricAsync(selectedMetric.Id, editMetric);
            ToastService.ShowSuccess("Métrica atualizada", "As alterações foram salvas com sucesso.");
            CloseEditMetricModal();
            await LoadMetrics();
        }
        catch (HttpRequestException ex)
        {
            Console.Error.WriteLine($"Erro HTTP ao atualizar métrica: {ex.Message}");
            ToastService.ShowError("Erro ao atualizar", "Não foi possível atualizar a métrica. Verifique os dados e tente novamente.");
        }
    }

    private async Task OnEditMetricTypeChanged(ChangeEventArgs e)
    {
        editMetricTypeValue = e.Value?.ToString();
        editMetric.TargetText = null;
        editMetric.MinValue = null;
        editMetric.MaxValue = null;
        editMetric.QuantitativeType = null;
        editQuantitativeTypeValue = null;
        editMetricUnitValue = null;
        await InvokeAsync(StateHasChanged);
    }

    // ---- Progress & Confidence Helpers ----

    private static string GetProgressStatusClass(MetricProgressDto progress)
    {
        if (!progress.HasCheckins)
        {
            return "no-data";
        }

        return progress.Progress switch
        {
            >= 70m => "on-track",
            >= 40m => "at-risk",
            _ => "off-track"
        };
    }

    private static (string statusClass, string label) GetConfidenceDisplay(int confidence)
    {
        return confidence switch
        {
            >= 4 => ("on-track", "No caminho"),
            >= 2 => ("at-risk", "Atenção"),
            _ => ("off-track", "Em risco")
        };
    }

    private static string GetConfidenceStarsText(int confidence)
    {
        var full = Math.Clamp(confidence, 0, 5);
        return new string('\u2605', full) + new string('\u2606', 5 - full);
    }

    // ---- Delete Methods ----

    private async Task HandleDeleteMetricClick(Guid metricId)
    {
        if (deletingMetricId == metricId)
        {
            await DeleteMetric(metricId);
        }
        else
        {
            deletingMetricId = metricId;
            deleteMetricConfirmTimer?.Dispose();
            deleteMetricConfirmTimer = new System.Threading.Timer(
                _ => InvokeAsync(() =>
                {
                    deletingMetricId = null;
                    StateHasChanged();
                }),
                null,
                3000,
                Timeout.Infinite
            );
        }
    }

    private async Task DeleteMetric(Guid metricId)
    {
        try
        {
            await Api.DeleteMissionMetricAsync(metricId);
            ToastService.ShowSuccess("Métrica excluída", "A métrica foi removida com sucesso.");
            await LoadMetrics();
        }
        catch (HttpRequestException ex)
        {
            Console.Error.WriteLine($"Erro HTTP ao excluir métrica: {ex.Message}");
            ToastService.ShowError("Erro ao excluir", "Não foi possível excluir a métrica. Tente novamente.");
        }
        finally
        {
            deletingMetricId = null;
            deleteMetricConfirmTimer?.Dispose();
            deleteMetricConfirmTimer = null;
        }
    }
}
